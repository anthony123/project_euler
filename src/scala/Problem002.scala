/**
  * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the
  * first 10 terms will be:
  * 
  * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
  * 
  * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the
  * even-valued terms.
  */

// This solution is based on two properties:
// 1) F(n) is even if n is a multiple of 3
// 2) F(n) = 4 * F(n - 3) + F(n - 6)
//
// Proof for 1):
// - F(3) = F(2) + F(1) = 1 + 1 = 2
// - F(n) is even and n is a multiple of 3.
//   F(n + 1) = F(n) + F(n - 1), with F(n) even and F(n - 1) odd => F(n + 1) is odd.
//   F(n + 2) = F(n + 1) + F(n), odd for the same reason.
//   F(n + 3) = F(n + 2) + F(n + 1)
//            = 2 * F(n + 1) + F(n)
//            => F(n) is even, 2 * F(n + 1) is even => F(n + 3) is even.
//
// Proof for 2):
// F(n) = F(n - 1) + F(n - 2)
//      = 2 * F(n - 2) + F(n - 3)
//      = 3 * F(n - 3) + 2 * F(n - 4)
//      = 3 * F(n - 3) + F(n - 4) + F(n - 5) + F(n - 6)
//      = 3 * F(n - 3) + F(n - 3) + F(n - 6)
//      = 4 * F(n - 3) + F(n - 6)
//
// With these two properties proven, we can create the sequence of even Fibonacci numbers E(n) such that:
// E(n) = F(3 * n)
//      = 4 * F(3 * (n - 3)) + F(3 * (n - 2))
//      = 4 * E(n - 3) + E(n - 2)

// This could be made faster by returning the sum of even fibonacci numbers, but I find it more versatile to return
// a collection of these numbers and let the caller do what he wants with them.
def evenFibonacci(max: Int) = {
  def evenFibonacciR(n2: Int, n1: Int, result: List[Int]): List[Int] = {
    val n = 4 * n1 + n2

    if(n > max) result
    else evenFibonacciR(n1, n, n :: result)
  }

  evenFibonacciR(2, 8, 2 :: 8 :: Nil)
}

EulerTimer {evenFibonacci(4000000).sum}
